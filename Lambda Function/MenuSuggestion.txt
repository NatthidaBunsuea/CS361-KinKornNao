// ===============================
// KinKornNao‚Ñ¢ Menu Suggestion Lambda (Improved)
// AI-Powered Recipe Recommendations
// Node.js 20.x
// ===============================

import {
  DynamoDBClient,
  GetItemCommand,
  PutItemCommand,
  QueryCommand,
} from "@aws-sdk/client-dynamodb";

const client = new DynamoDBClient({ region: "us-east-1" });
const INVENTORY_TABLE = "KKN-Inventory";
const CACHE_TABLE = "KKN-SuggestionCache";
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;

// ===============================
// Response helper
// ===============================
function response(statusCode, body) {
  return {
    statusCode,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "*",
      "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    },
    body: JSON.stringify(body),
  };
}

// ===============================
// Get user's ingredients
// ===============================
async function getUserIngredients(ownerId) {
  console.log("üì¶ Getting ingredients for owner:", ownerId);

  const data = await client.send(
    new QueryCommand({
      TableName: INVENTORY_TABLE,
      KeyConditionExpression: "OwnerId = :o",
      ExpressionAttributeValues: {
        ":o": { S: ownerId },
      },
    })
  );

  const items = (data.Items || []).map((i) => ({
    name: i.Name?.S || "",
    category: i.Category?.S || "",
    quantity: Number(i.Quantity?.N || 0),
    unit: i.Unit?.S || "",
    expiryDate: i.ExpiryDate?.S || "",
    status: i.Status?.S || "valid",
  }));

  // Filter only valid items
  const validItems = items.filter(i => i.status === "valid" && i.name);

  console.log(`‚úÖ Found ${validItems.length} valid ingredients`);
  return validItems;
}

// ===============================
// Check cache
// ===============================
async function checkCache(ownerId) {
  console.log("üîç Checking cache for owner:", ownerId);

  try {
    const data = await client.send(
      new GetItemCommand({
        TableName: CACHE_TABLE,
        Key: {
          OwnerId: { S: ownerId },
        },
      })
    );

    if (!data.Item) {
      console.log("‚ùå No cache found");
      return null;
    }

    const cachedAt = data.Item.CachedAt?.S;
    const ttl = 300000; // 5 minutes (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö testing)
    const age = Date.now() - new Date(cachedAt).getTime();

    if (age > ttl) {
      console.log("‚è∞ Cache expired (age:", Math.round(age/60000), "minutes)");
      return null;
    }

    console.log("‚úÖ Cache hit! (age:", Math.round(age/60000), "minutes)");
    return JSON.parse(data.Item.Suggestions?.S || "[]");
  } catch (error) {
    console.warn("‚ö†Ô∏è Cache check error:", error.message);
    return null;
  }
}

// ===============================
// Save to cache
// ===============================
async function saveCache(ownerId, suggestions) {
  console.log("üíæ Saving to cache for owner:", ownerId);

  try {
    await client.send(
      new PutItemCommand({
        TableName: CACHE_TABLE,
        Item: {
          OwnerId: { S: ownerId },
          Suggestions: { S: JSON.stringify(suggestions) },
          CachedAt: { S: new Date().toISOString() },
          TTL: { N: String(Math.floor(Date.now() / 1000) + 3600) },
        },
      })
    );
    console.log("‚úÖ Cache saved successfully");
  } catch (error) {
    console.warn("‚ö†Ô∏è Failed to save cache:", error.message);
  }
}

// ===============================
// Call Claude API for suggestions
// ===============================
async function getAISuggestions(ingredients) {
  console.log("ü§ñ Calling Claude API for suggestions...");

  // ‚ö†Ô∏è TEMPORARY: Skip API call if no credits
  // Remove this when API key has credits
  if (!ANTHROPIC_API_KEY || ANTHROPIC_API_KEY === "SKIP_FOR_NOW") {
    console.warn("‚ö†Ô∏è Skipping Claude API (no credits or disabled)");
    return getFallbackSuggestions(ingredients);
  }

  // Prepare ingredient list
  const ingredientList = ingredients
    .map((i) => {
      const expiry = i.expiryDate ? new Date(i.expiryDate) : null;
      const daysLeft = expiry ? Math.ceil((expiry - new Date()) / 86400000) : null;
      const expiryText = daysLeft !== null ? `‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô‡∏≠‡∏µ‡∏Å ${daysLeft} ‡∏ß‡∏±‡∏ô` : "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡∏±‡∏ô‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏";
      return `- ${i.name} (${i.quantity} ${i.unit}, ${expiryText}, ‡∏´‡∏°‡∏ß‡∏î: ${i.category || "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏"})`;
    })
    .join("\n");

  const prompt = `‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ä‡∏ü‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏µ‡πà‡∏¢‡∏ß‡∏ä‡∏≤‡∏ç‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÑ‡∏ó‡∏¢‡πÅ‡∏•‡∏∞‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ô‡∏≤‡∏ô‡∏≤‡∏ä‡∏≤‡∏ï‡∏¥ ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏°‡∏µ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏ï‡∏π‡πâ‡πÄ‡∏¢‡πá‡∏ô:

${ingredientList}

‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ 3-5 ‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ ‡πÇ‡∏î‡∏¢‡∏Ñ‡∏≥‡∏ô‡∏∂‡∏á‡∏ñ‡∏∂‡∏á:
1. ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏Å‡πà‡∏≠‡∏ô (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î food waste)
2. ‚è±Ô∏è ‡πÄ‡∏°‡∏ô‡∏π‡∏Ñ‡∏ß‡∏£‡∏ó‡∏≥‡∏á‡πà‡∏≤‡∏¢ ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 45 ‡∏ô‡∏≤‡∏ó‡∏µ
3. üè† ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ó‡∏µ‡πà‡∏ö‡πâ‡∏≤‡∏ô ‡πÑ‡∏°‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô
4. üçΩÔ∏è ‡πÉ‡∏´‡πâ‡∏ó‡∏±‡πâ‡∏á‡πÄ‡∏°‡∏ô‡∏π‡πÑ‡∏ó‡∏¢‡πÅ‡∏•‡∏∞‡∏™‡∏≤‡∏Å‡∏• ‡∏´‡∏•‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢

**‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å: ‡∏ï‡∏≠‡∏ö‡πÄ‡∏õ‡πá‡∏ô JSON ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏´‡πâ‡∏≤‡∏°‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏∑‡πà‡∏ô ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ markdown code block**

‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£:
{
  "suggestions": [
    {
      "title": "‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏π‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢",
      "time": 15,
      "difficulty": "‡∏á‡πà‡∏≤‡∏¢",
      "ingredients": [
        {"name": "‡∏ä‡∏∑‡πà‡∏≠‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö", "qty": "2 ‡∏ä‡πâ‡∏≠‡∏ô‡πÇ‡∏ï‡πä‡∏∞"}
      ],
      "steps": [
        "‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1 ‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô",
        "‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2",
        "‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3"
      ],
      "matchedIngredients": ["‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡∏ï‡∏π‡πâ‡πÄ‡∏¢‡πá‡∏ô"],
      "additionalIngredients": ["‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏° (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)"]
    }
  ]
}

‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:
- difficulty ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÉ‡∏ô: "‡∏á‡πà‡∏≤‡∏¢", "‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á", "‡∏¢‡∏≤‡∏Å"
- time ‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ô‡∏≤‡∏ó‡∏µ (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç)
- ‡∏ï‡∏≠‡∏ö‡πÄ‡∏õ‡πá‡∏ô valid JSON ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô`;

  try {
    console.log("üì§ Sending request to Claude API...");
    console.log("üîë API Key (first 10 chars):", ANTHROPIC_API_KEY?.substring(0, 10) + "...");
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 25000); // 25 second timeout
    
    const apiResponse = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": ANTHROPIC_API_KEY,
        "anthropic-version": "2023-06-01",
      },
      body: JSON.stringify({
        model: "claude-sonnet-4-20250514",
        max_tokens: 4096,
        temperature: 0.7,
        messages: [
          {
            role: "user",
            content: prompt,
          },
        ],
      }),
      signal: controller.signal
    }).finally(() => clearTimeout(timeoutId));

    console.log("üì• Response status:", apiResponse.status);

    if (!apiResponse.ok) {
      const errorText = await apiResponse.text();
      console.error("‚ùå Claude API error:", apiResponse.status, errorText);
      throw new Error(`API error: ${apiResponse.status} - ${errorText}`);
    }

    const data = await apiResponse.json();
    console.log("üì• Claude API response received");

    const content = data.content?.[0]?.text;
    if (!content) {
      throw new Error("No content in API response");
    }

    console.log("üìÑ Raw response length:", content.length);

    // Try to extract JSON from response
    let jsonText = content.trim();
    
    // Remove markdown code blocks if present
    jsonText = jsonText.replace(/```json\n?/g, "").replace(/```\n?/g, "");
    
    // Find JSON object
    const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      console.error("‚ùå No JSON found in response");
      console.log("Response preview:", content.substring(0, 200));
      throw new Error("Invalid response format - no JSON found");
    }

    const result = JSON.parse(jsonMatch[0]);
    
    if (!result.suggestions || !Array.isArray(result.suggestions)) {
      throw new Error("Invalid response structure - missing suggestions array");
    }

    console.log(`‚úÖ Generated ${result.suggestions.length} suggestions`);
    
    // Validate and clean suggestions
    const validSuggestions = result.suggestions
      .filter(s => s.title && s.ingredients && s.steps)
      .map(s => ({
        title: s.title,
        time: Number(s.time) || 20,
        difficulty: ["‡∏á‡πà‡∏≤‡∏¢", "‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á", "‡∏¢‡∏≤‡∏Å"].includes(s.difficulty) ? s.difficulty : "‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á",
        ingredients: Array.isArray(s.ingredients) ? s.ingredients : [],
        steps: Array.isArray(s.steps) ? s.steps : [],
        matchedIngredients: Array.isArray(s.matchedIngredients) ? s.matchedIngredients : [],
        additionalIngredients: Array.isArray(s.additionalIngredients) ? s.additionalIngredients : []
      }));

    console.log(`‚úÖ Validated ${validSuggestions.length} suggestions`);
    
    return validSuggestions;

  } catch (error) {
    console.error("‚ùå AI suggestion error:", error.message);
    console.error("Stack:", error.stack);
    return getFallbackSuggestions(ingredients);
  }
}

// ===============================
// Fallback suggestions
// ===============================
function getFallbackSuggestions(ingredients) {
  console.log("üîÑ Using smart fallback suggestions based on ingredients");

  const suggestions = [];
  
  // Analyze available ingredients
  const hasEggs = ingredients.some((i) => 
    i.name.toLowerCase().includes("‡πÑ‡∏Ç‡πà") || 
    i.name.toLowerCase().includes("egg")
  );
  
  const hasRice = ingredients.some((i) => 
    i.name.toLowerCase().includes("‡∏Ç‡πâ‡∏≤‡∏ß") || 
    i.name.toLowerCase().includes("rice")
  );
  
  const veggies = ingredients.filter((i) => 
    i.category === "‡∏ú‡∏±‡∏Å" || 
    i.category.toLowerCase().includes("vegetable") ||
    i.name.toLowerCase().includes("‡∏Ñ‡∏∞‡∏ô‡πâ‡∏≤") ||
    i.name.toLowerCase().includes("‡∏ú‡∏±‡∏Å")
  );
  
  const proteins = ingredients.filter((i) => 
    i.category === "‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô" || 
    i.category.toLowerCase().includes("protein") ||
    i.name.toLowerCase().includes("‡∏´‡∏°‡∏π") ||
    i.name.toLowerCase().includes("‡πÑ‡∏Å‡πà") ||
    i.name.toLowerCase().includes("pork") ||
    i.name.toLowerCase().includes("chicken") ||
    i.name.toLowerCase().includes("‡πÄ‡∏ô‡∏∑‡πâ‡∏≠")
  );

  const hasPork = proteins.some(p => p.name.toLowerCase().includes("‡∏´‡∏°‡∏π") || p.name.toLowerCase().includes("pork"));
  const hasKale = veggies.some(v => v.name.toLowerCase().includes("‡∏Ñ‡∏∞‡∏ô‡πâ‡∏≤") || v.name.toLowerCase().includes("kale"));

  console.log(`üìä Analysis: ${hasEggs ? '‚úÖ' : '‚ùå'} Eggs, ${hasPork ? '‚úÖ' : '‚ùå'} Pork, ${hasKale ? '‚úÖ' : '‚ùå'} Kale`);

  // Suggestion 1: ‡∏ú‡∏±‡∏î‡∏Ñ‡∏∞‡∏ô‡πâ‡∏≤‡∏´‡∏°‡∏π‡∏Å‡∏£‡∏≠‡∏ö (if have both)
  if (hasPork && hasKale) {
    suggestions.push({
      title: "‡∏ú‡∏±‡∏î‡∏Ñ‡∏∞‡∏ô‡πâ‡∏≤‡∏´‡∏°‡∏π‡∏Å‡∏£‡∏≠‡∏ö",
      time: 20,
      difficulty: "‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á",
      ingredients: [
        { name: "‡∏´‡∏°‡∏π", qty: "200 ‡∏Å‡∏£‡∏±‡∏°" },
        { name: "‡∏ú‡∏±‡∏Å‡∏Ñ‡∏∞‡∏ô‡πâ‡∏≤", qty: "200 ‡∏Å‡∏£‡∏±‡∏°" },
        { name: "‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°", qty: "3 ‡∏Å‡∏•‡∏µ‡∏ö" },
        { name: "‡∏ã‡∏≠‡∏™‡∏´‡∏≠‡∏¢‡∏ô‡∏≤‡∏á‡∏£‡∏°", qty: "2 ‡∏ä‡πâ‡∏≠‡∏ô‡πÇ‡∏ï‡πä‡∏∞" },
        { name: "‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô", qty: "3 ‡∏ä‡πâ‡∏≠‡∏ô‡πÇ‡∏ï‡πä‡∏∞" },
      ],
      steps: [
        "‡∏´‡∏±‡πà‡∏ô‡∏´‡∏°‡∏π‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏¥‡πâ‡∏ô‡∏ö‡∏≤‡∏á‡πÜ ‡∏´‡∏±‡πà‡∏ô‡∏ú‡∏±‡∏Å‡∏Ñ‡∏∞‡∏ô‡πâ‡∏≤ ‡∏™‡∏±‡∏ö‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°",
        "‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏∞‡πÉ‡∏™‡πà‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô‡πÉ‡∏´‡πâ‡∏£‡πâ‡∏≠‡∏ô‡∏à‡∏±‡∏î ‡∏ó‡∏≠‡∏î‡∏´‡∏°‡∏π‡∏à‡∏ô‡∏Å‡∏£‡∏≠‡∏ö ‡∏ï‡∏±‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô",
        "‡πÉ‡∏ä‡πâ‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô‡πÄ‡∏î‡∏¥‡∏° ‡∏ú‡∏±‡∏î‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°‡πÉ‡∏´‡πâ‡∏´‡∏≠‡∏°",
        "‡πÉ‡∏™‡πà‡∏ú‡∏±‡∏Å‡∏Ñ‡∏∞‡∏ô‡πâ‡∏≤‡∏•‡∏á‡∏ú‡∏±‡∏î ‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™‡∏î‡πâ‡∏ß‡∏¢‡∏ã‡∏≠‡∏™‡∏´‡∏≠‡∏¢‡∏ô‡∏≤‡∏á‡∏£‡∏°",
        "‡πÉ‡∏™‡πà‡∏´‡∏°‡∏π‡∏Å‡∏£‡∏≠‡∏ö‡∏•‡∏á‡∏Ñ‡∏•‡∏∏‡∏Å ‡∏ï‡∏±‡∏Å‡πÉ‡∏™‡πà‡∏à‡∏≤‡∏ô"
      ],
      matchedIngredients: ["‡∏´‡∏°‡∏π", "‡∏ú‡∏±‡∏Å‡∏Ñ‡∏∞‡∏ô‡πâ‡∏≤"],
      additionalIngredients: ["‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°", "‡∏ã‡∏≠‡∏™‡∏´‡∏≠‡∏¢‡∏ô‡∏≤‡∏á‡∏£‡∏°", "‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô"]
    });
  }

  // Suggestion 2: ‡∏Ç‡πâ‡∏≤‡∏ß‡∏ú‡∏±‡∏î‡∏´‡∏°‡∏π (if have pork and eggs)
  if (hasPork && hasEggs) {
    suggestions.push({
      title: "‡∏Ç‡πâ‡∏≤‡∏ß‡∏ú‡∏±‡∏î‡∏´‡∏°‡∏π",
      time: 15,
      difficulty: "‡∏á‡πà‡∏≤‡∏¢",
      ingredients: [
        { name: "‡∏Ç‡πâ‡∏≤‡∏ß‡∏™‡∏ß‡∏¢", qty: "2 ‡∏à‡∏≤‡∏ô" },
        { name: "‡∏´‡∏°‡∏π‡∏™‡∏±‡∏ö", qty: "100 ‡∏Å‡∏£‡∏±‡∏°" },
        { name: "‡πÑ‡∏Ç‡πà", qty: "2 ‡∏ü‡∏≠‡∏á" },
        { name: "‡∏ã‡∏≠‡∏™‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™", qty: "2 ‡∏ä‡πâ‡∏≠‡∏ô‡πÇ‡∏ï‡πä‡∏∞" },
        { name: "‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô", qty: "2 ‡∏ä‡πâ‡∏≠‡∏ô‡πÇ‡∏ï‡πä‡∏∞" },
      ],
      steps: [
        "‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏∞‡πÉ‡∏™‡πà‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô‡πÉ‡∏´‡πâ‡∏£‡πâ‡∏≠‡∏ô",
        "‡πÉ‡∏™‡πà‡πÑ‡∏Ç‡πà‡∏•‡∏á‡∏ï‡∏µ ‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏™‡πà‡∏´‡∏°‡∏π‡∏™‡∏±‡∏ö‡∏•‡∏á‡∏ú‡∏±‡∏î",
        "‡πÉ‡∏™‡πà‡∏Ç‡πâ‡∏≤‡∏ß‡∏•‡∏á‡∏ú‡∏±‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ô",
        "‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™‡∏î‡πâ‡∏ß‡∏¢‡∏ã‡∏≠‡∏™‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™",
        "‡∏ï‡∏±‡∏Å‡πÉ‡∏™‡πà‡∏à‡∏≤‡∏ô ‡πÇ‡∏£‡∏¢‡∏ï‡πâ‡∏ô‡∏´‡∏≠‡∏°"
      ],
      matchedIngredients: ["‡∏´‡∏°‡∏π", "‡πÑ‡∏Ç‡πà"],
      additionalIngredients: ["‡∏Ç‡πâ‡∏≤‡∏ß‡∏™‡∏ß‡∏¢", "‡∏ã‡∏≠‡∏™‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™", "‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô"]
    });
  }

  // Suggestion 3: Omelet
  if (hasEggs) {
    const eggItem = ingredients.find(i => 
      i.name.toLowerCase().includes("‡πÑ‡∏Ç‡πà") || 
      i.name.toLowerCase().includes("egg")
    );
    
    suggestions.push({
      title: "‡πÑ‡∏Ç‡πà‡πÄ‡∏à‡∏µ‡∏¢‡∏ß",
      time: 10,
      difficulty: "‡∏á‡πà‡∏≤‡∏¢",
      ingredients: [
        { name: "‡πÑ‡∏Ç‡πà", qty: "2 ‡∏ü‡∏≠‡∏á" },
        { name: "‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô", qty: "3 ‡∏ä‡πâ‡∏≠‡∏ô‡πÇ‡∏ï‡πä‡∏∞" },
        { name: "‡∏ã‡∏≠‡∏™‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™", qty: "‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢" },
      ],
      steps: [
        "‡∏ï‡∏µ‡πÑ‡∏Ç‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ô ‡πÉ‡∏™‡πà‡∏ã‡∏≠‡∏™‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢",
        "‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏∞‡πÉ‡∏™‡πà‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô ‡πÉ‡∏´‡πâ‡∏£‡πâ‡∏≠‡∏ô‡∏à‡∏±‡∏î",
        "‡πÄ‡∏ó‡πÑ‡∏Ç‡πà‡∏•‡∏á‡πÑ‡∏õ ‡∏£‡∏≠‡∏à‡∏ô‡∏™‡∏∏‡∏Å‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á",
        "‡∏û‡∏•‡∏¥‡∏Å‡∏≠‡∏µ‡∏Å‡∏î‡πâ‡∏≤‡∏ô ‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡∏à‡∏∂‡∏á‡∏ï‡∏±‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô",
        "‡πÄ‡∏™‡∏¥‡∏£‡πå‡∏ü‡∏£‡πâ‡∏≠‡∏ô‡πÜ ‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≤‡∏ß‡∏™‡∏ß‡∏¢"
      ],
      matchedIngredients: [eggItem ? eggItem.name : "‡πÑ‡∏Ç‡πà"],
      additionalIngredients: ["‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô", "‡∏ã‡∏≠‡∏™‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™"]
    });
  }

  // Suggestion 4: ‡∏ï‡πâ‡∏°‡∏à‡∏∑‡∏î‡∏ú‡∏±‡∏Å (if have vegetables)
  if (veggies.length > 0) {
    suggestions.push({
      title: "‡∏ï‡πâ‡∏°‡∏à‡∏∑‡∏î‡∏ú‡∏±‡∏Å‡∏£‡∏ß‡∏°",
      time: 15,
      difficulty: "‡∏á‡πà‡∏≤‡∏¢",
      ingredients: [
        { name: veggies[0].name, qty: "200 ‡∏Å‡∏£‡∏±‡∏°" },
        { name: "‡πÄ‡∏ï‡πâ‡∏≤‡∏´‡∏π‡πâ", qty: "1 ‡πÅ‡∏ú‡πà‡∏ô" },
        { name: "‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°", qty: "2 ‡∏Å‡∏•‡∏µ‡∏ö" },
        { name: "‡∏ô‡πâ‡∏≥‡∏ã‡∏∏‡∏õ", qty: "3 ‡∏ñ‡πâ‡∏ß‡∏¢" },
      ],
      steps: [
        "‡∏ï‡∏±‡πâ‡∏á‡∏´‡∏°‡πâ‡∏≠‡∏ô‡πâ‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏î ‡πÉ‡∏™‡πà‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°‡∏ó‡∏∏‡∏ö",
        "‡πÉ‡∏™‡πà‡πÄ‡∏ï‡πâ‡∏≤‡∏´‡∏π‡πâ‡∏´‡∏±‡πà‡∏ô‡∏•‡∏á‡πÑ‡∏õ",
        "‡πÉ‡∏™‡πà‡∏ú‡∏±‡∏Å‡∏•‡∏á‡∏ï‡πâ‡∏°",
        "‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™‡∏ï‡∏≤‡∏°‡∏ä‡∏≠‡∏ö",
        "‡∏ï‡∏±‡∏Å‡πÉ‡∏™‡πà‡∏ä‡∏≤‡∏° ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏™‡∏¥‡∏£‡πå‡∏ü"
      ],
      matchedIngredients: veggies.map(v => v.name),
      additionalIngredients: ["‡πÄ‡∏ï‡πâ‡∏≤‡∏´‡∏π‡πâ", "‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°", "‡∏ô‡πâ‡∏≥‡∏ã‡∏∏‡∏õ"]
    });
  }

  // Suggestion 5: ‡∏ú‡∏±‡∏î‡∏Å‡∏∞‡πÄ‡∏û‡∏£‡∏≤ (if have protein)
  if (proteins.length > 0) {
    suggestions.push({
      title: "‡∏ú‡∏±‡∏î‡∏Å‡∏∞‡πÄ‡∏û‡∏£‡∏≤‡∏´‡∏°‡∏π",
      time: 20,
      difficulty: "‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á",
      ingredients: [
        { name: proteins[0].name, qty: "200 ‡∏Å‡∏£‡∏±‡∏°" },
        { name: "‡∏Å‡∏∞‡πÄ‡∏û‡∏£‡∏≤", qty: "1 ‡∏Å‡∏≥‡∏°‡∏∑‡∏≠" },
        { name: "‡∏û‡∏£‡∏¥‡∏Å", qty: "5 ‡πÄ‡∏°‡πá‡∏î" },
        { name: "‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°", qty: "3 ‡∏Å‡∏•‡∏µ‡∏ö" },
        { name: "‡∏ã‡∏≠‡∏™‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™", qty: "2 ‡∏ä‡πâ‡∏≠‡∏ô‡πÇ‡∏ï‡πä‡∏∞" },
      ],
      steps: [
        "‡πÇ‡∏Ç‡∏•‡∏Å‡∏û‡∏£‡∏¥‡∏Å‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°‡πÉ‡∏´‡πâ‡πÅ‡∏´‡∏•‡∏Å",
        "‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏∞‡πÉ‡∏™‡πà‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô ‡∏ú‡∏±‡∏î‡∏û‡∏£‡∏¥‡∏Å‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°‡πÉ‡∏´‡πâ‡∏´‡∏≠‡∏°",
        `‡πÉ‡∏™‡πà${proteins[0].name}‡∏•‡∏á‡∏ú‡∏±‡∏î‡∏à‡∏ô‡∏™‡∏∏‡∏Å`,
        "‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™‡∏ï‡∏≤‡∏°‡∏ä‡∏≠‡∏ö",
        "‡πÉ‡∏™‡πà‡∏Å‡∏∞‡πÄ‡∏û‡∏£‡∏≤‡∏Ñ‡∏•‡∏∏‡∏Å‡πÄ‡∏Ñ‡∏•‡πâ‡∏≤ ‡∏õ‡∏¥‡∏î‡πÑ‡∏ü",
        "‡∏ï‡∏±‡∏Å‡πÉ‡∏™‡πà‡∏à‡∏≤‡∏ô ‡πÄ‡∏™‡∏¥‡∏£‡πå‡∏ü‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≤‡∏ß‡∏™‡∏ß‡∏¢‡πÅ‡∏•‡∏∞‡πÑ‡∏Ç‡πà‡∏î‡∏≤‡∏ß"
      ],
      matchedIngredients: [proteins[0].name],
      additionalIngredients: ["‡∏Å‡∏∞‡πÄ‡∏û‡∏£‡∏≤", "‡∏û‡∏£‡∏¥‡∏Å", "‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°", "‡∏ã‡∏≠‡∏™‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™"]
    });
  }

  // Default if nothing matches
  if (suggestions.length === 0) {
    suggestions.push({
      title: "‡∏Ç‡πâ‡∏≤‡∏ß‡∏ú‡∏±‡∏î‡πÑ‡∏Ç‡πà",
      time: 15,
      difficulty: "‡∏á‡πà‡∏≤‡∏¢",
      ingredients: [
        { name: "‡∏Ç‡πâ‡∏≤‡∏ß‡∏™‡∏ß‡∏¢", qty: "2 ‡∏à‡∏≤‡∏ô" },
        { name: "‡πÑ‡∏Ç‡πà", qty: "2 ‡∏ü‡∏≠‡∏á" },
        { name: "‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô", qty: "2 ‡∏ä‡πâ‡∏≠‡∏ô‡πÇ‡∏ï‡πä‡∏∞" },
      ],
      steps: [
        "‡∏ï‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏∞‡πÉ‡∏´‡πâ‡∏£‡πâ‡∏≠‡∏ô ‡πÉ‡∏™‡πà‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô",
        "‡πÉ‡∏™‡πà‡πÑ‡∏Ç‡πà‡∏•‡∏á‡πÑ‡∏õ‡∏ï‡∏µ‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢",
        "‡πÉ‡∏™‡πà‡∏Ç‡πâ‡∏≤‡∏ß‡∏•‡∏á‡∏ú‡∏±‡∏î‡∏à‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ô",
        "‡∏õ‡∏£‡∏∏‡∏á‡∏£‡∏™‡∏ï‡∏≤‡∏°‡∏ä‡∏≠‡∏ö",
        "‡∏ï‡∏±‡∏Å‡πÉ‡∏™‡πà‡∏à‡∏≤‡∏ô ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏™‡∏¥‡∏£‡πå‡∏ü"
      ],
      matchedIngredients: [],
      additionalIngredients: ["‡∏Ç‡πâ‡∏≤‡∏ß‡∏™‡∏ß‡∏¢", "‡πÑ‡∏Ç‡πà", "‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô"]
    });
  }

  console.log(`‚úÖ Generated ${suggestions.length} smart fallback suggestions`);
  return suggestions;
}

// ===============================
// MAIN HANDLER
// ===============================
export const handler = async (event) => {
  console.log("üöÄ Lambda invoked");
  console.log("EVENT:", JSON.stringify(event, null, 2));

  const method = event.requestContext?.http?.method || event.httpMethod;
  const rawPath = event.requestContext?.http?.path || event.path || "";

  console.log("Method:", method, "Path:", rawPath);

  // Handle CORS preflight
  if (method === "OPTIONS") {
    return response(200, { message: "CORS OK" });
  }

  try {
    // GET /suggestions?ownerId=xxx
    if (method === "GET" && rawPath === "/suggestions") {
      const ownerId =
        event.queryStringParameters?.ownerId ||
        event.headers["x-user-id"] ||
        event.headers["X-User-Id"];

      console.log("üìã GET /suggestions - OwnerId:", ownerId);

      if (!ownerId) {
        return response(400, { error: "Missing ownerId parameter" });
      }

      // Check cache first
      const cached = await checkCache(ownerId);
      if (cached && cached.length > 0) {
        console.log("‚úÖ Returning cached suggestions");
        return response(200, {
          suggestions: cached,
          fromCache: true,
          timestamp: new Date().toISOString()
        });
      }

      // Get user's ingredients
      const ingredients = await getUserIngredients(ownerId);

      if (ingredients.length === 0) {
        console.log("‚ö†Ô∏è No ingredients found");
        return response(200, {
          suggestions: [],
          message: "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡πÉ‡∏ô‡∏ï‡∏π‡πâ‡πÄ‡∏¢‡πá‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô",
          fromCache: false
        });
      }

      // Get AI suggestions
      const suggestions = await getAISuggestions(ingredients);

      // Save to cache (even fallback)
      if (suggestions.length > 0) {
        await saveCache(ownerId, suggestions);
      }

      return response(200, {
        suggestions,
        fromCache: false,
        ingredientCount: ingredients.length,
        timestamp: new Date().toISOString()
      });
    }

    // POST /suggestions/refresh - Force refresh
    if (method === "POST" && rawPath === "/suggestions/refresh") {
      const ownerId =
        event.headers["x-user-id"] ||
        event.headers["X-User-Id"] ||
        (event.body ? JSON.parse(event.body).ownerId : null);

      console.log("üîÑ POST /suggestions/refresh - OwnerId:", ownerId);

      if (!ownerId) {
        return response(400, { error: "Missing ownerId" });
      }

      const ingredients = await getUserIngredients(ownerId);

      if (ingredients.length === 0) {
        return response(200, {
          suggestions: [],
          message: "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡πÉ‡∏ô‡∏ï‡∏π‡πâ‡πÄ‡∏¢‡πá‡∏ô",
          fromCache: false
        });
      }

      // Force new AI generation
      const suggestions = await getAISuggestions(ingredients);
      
      if (suggestions.length > 0) {
        await saveCache(ownerId, suggestions);
      }

      return response(200, {
        suggestions,
        fromCache: false,
        refreshed: true,
        ingredientCount: ingredients.length,
        timestamp: new Date().toISOString()
      });
    }

    // Route not found
    return response(404, {
      error: "Route not found",
      method,
      path: rawPath,
      availableRoutes: [
        "GET /suggestions?ownerId=xxx",
        "POST /suggestions/refresh"
      ]
    });

  } catch (err) {
    console.error("‚ùå ERROR:", err);
    console.error("Stack:", err.stack);
    
    return response(500, {
      error: "Internal server error",
      message: err.message,
      timestamp: new Date().toISOString()
    });
  }
};